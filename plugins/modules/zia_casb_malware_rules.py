#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# Copyright (c) 2023 Zscaler Inc, <devrel@zscaler.com>

#                             MIT License
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from __future__ import absolute_import, division, print_function

__metaclass__ = type

DOCUMENTATION = r"""
---
module: zia_casb_malware_rules
short_description: "Manages CASB Malware rules"
description:
  - "Adds, updates, or removes SaaS Security Data at Rest Scanning Malware rules."
author:
  - William Guilherme (@willguibr)
version_added: "1.0.0"
requirements:
    - Zscaler SDK Python can be obtained from PyPI U(https://pypi.org/project/zscaler-sdk-python/)
notes:
    - Check mode is supported.
    - C(type) and C(name) are required for create. C(type) with C(id) or C(name) for update/delete.
extends_documentation_fragment:
  - zscaler.ziacloud.fragments.provider
  - zscaler.ziacloud.fragments.documentation
  - zscaler.ziacloud.fragments.state

options:
  id:
    description:
      - The unique identifier for the CASB Malware rule.
      - Used to reference an existing rule for update or delete.
    required: false
    type: int
  name:
    description: Rule name.
    required: true
    type: str
  type:
    description:
      - The type of SaaS Security Data at Rest Scanning Malware rule.
    required: true
    type: str
    choices:
      - OFLCASB_AVP_FILE
      - OFLCASB_AVP_EMAIL
      - OFLCASB_AVP_CRM
      - OFLCASB_AVP_ITSM
      - OFLCASB_AVP_COLLAB
      - OFLCASB_AVP_REPO
      - OFLCASB_AVP_STORAGE
      - OFLCASB_AVP_GENAI
  order:
    description:
      - Order of rule execution with respect to other SaaS Security Data at Rest Scanning Malware rules.
    required: true
    type: int
  description:
    description:
      - An admin editable text-based description of the rule.
      - Accepted for playbook compatibility; CASB Malware API may not support or return this field.
    required: false
    type: str
  rank:
    description:
      - Admin rank assigned to this rule. Mandatory when admin rank-based access restriction is enabled.
      - Accepted for playbook compatibility; CASB Malware API may not support or return this field.
    required: false
    type: int
  enabled:
    description:
      - Administrative state of the rule.
      - If C(true), rule is ENABLED. If C(false), rule is DISABLED.
    required: false
    type: bool
  action:
    description: The configured action for the policy rule.
    required: false
    type: str
    choices:
      - OFLCASB_AVP_QUARANTINE
      - OFLCASB_AVP_REMOVE
      - OFLCASB_AVP_REPORT_MALWARE
      - OFLCASB_AVP_APPLY_EMAIL_TAG
      - OFLCASB_AVP_BLOCK
      - OFLCASB_AVP_ALLOW
  quarantine_location:
    description:
      - Location where all the quarantined files are moved and necessary actions are taken.
    required: false
    type: str
  scan_inbound_email_link:
    description: Enables or disables the scan inbound email link.
    required: false
    type: str
    choices:
      - SCAN_EMAIL_LINK_ENABLE
      - SCAN_EMAIL_LINK_DISABLE
  cloud_app_tenant_ids:
    description: List of cloud application tenant IDs for which the rule is applied.
    required: false
    type: list
    elements: int
  labels:
    description: List of rule label IDs associated with the rule.
    required: false
    type: list
    elements: int
  bucket_ids:
    description:
      - List of bucket IDs for the Zscaler service to inspect for sensitive data.
    required: false
    type: list
    elements: int
  casb_email_label:
    description: Email label associated with the rule. Provide as dict with C(id) key.
    required: false
    type: dict
  casb_tombstone_template:
    description: Quarantine tombstone template. Provide as dict with C(id) key.
    required: false
    type: dict
"""

EXAMPLES = r"""
- name: Create a CASB Malware rule
  zscaler.ziacloud.zia_casb_malware_rules:
    provider: '{{ provider }}'
    name: "My Malware Rule"
    type: OFLCASB_AVP_REPO
    order: 1
    action: OFLCASB_AVP_REPORT_MALWARE
    enabled: true
    cloud_app_tenant_ids:
      - 15881081
    labels:
      - 1441065
    bucket_ids:
      - 1442271
      - 1442270

- name: Update a CASB Malware rule by ID
  zscaler.ziacloud.zia_casb_malware_rules:
    provider: '{{ provider }}'
    id: 1072401
    type: OFLCASB_AVP_REPO
    name: "Updated Rule Name"
    order: 1

- name: Delete a CASB Malware rule
  zscaler.ziacloud.zia_casb_malware_rules:
    provider: '{{ provider }}'
    id: 1072401
    type: OFLCASB_AVP_REPO
    state: absent
"""

RETURN = r"""
data:
  description: The CASB Malware rule resource record.
  returned: on success
  type: dict
"""

from traceback import format_exc

from ansible.module_utils._text import to_native
from ansible.module_utils.basic import AnsibleModule
from ansible_collections.zscaler.ziacloud.plugins.module_utils.zia_client import (
    ZIAClientHelper,
)

RULE_TYPE_CHOICES = [
    "OFLCASB_AVP_FILE",
    "OFLCASB_AVP_EMAIL",
    "OFLCASB_AVP_CRM",
    "OFLCASB_AVP_ITSM",
    "OFLCASB_AVP_COLLAB",
    "OFLCASB_AVP_REPO",
    "OFLCASB_AVP_STORAGE",
    "OFLCASB_AVP_GENAI",
]

# Attributes compared for idempotency. Exclude description/rank - CASB Malware API
# does not return them (SDK model has no description/rank), which would cause false drift.
CASB_MALWARE_RULE_ATTRIBUTES = [
    "name",
    "order",
    "enabled",
    "action",
    "quarantine_location",
    "scan_inbound_email_link",
    "cloud_app_tenant_ids",
    "labels",
    "bucket_ids",
    "casb_email_label",
    "casb_tombstone_template",
]

# API returns cloud_app_tenants, buckets; we use cloud_app_tenant_ids, bucket_ids
ID_LIST_ATTRS = ["cloud_app_tenant_ids", "labels", "bucket_ids"]
API_TO_MODULE_MAP = {"buckets": "bucket_ids", "cloud_app_tenants": "cloud_app_tenant_ids"}


def _normalize_list(val):
    if val is None:
        return None
    if isinstance(val, list):
        return sorted([str(x) for x in val]) if val else []
    return val


def _extract_ids(val):
    if val is None:
        return None
    if not isinstance(val, list):
        return val
    ids = []
    for item in val:
        if isinstance(item, dict) and "id" in item:
            ids.append(item["id"])
        elif isinstance(item, (int, float)):
            ids.append(int(item))
        else:
            ids.append(item)
    return sorted([str(x) for x in ids])


def _normalize_single_ref(val):
    if val is None:
        return None
    if isinstance(val, dict) and "id" in val:
        return {"id": val["id"]}
    return val


def normalize_rule(rule):
    if not rule:
        return {}
    norm = rule.copy()
    norm.pop("id", None)
    norm.pop("last_modified_time", None)
    # Map API response keys to module param keys
    for api_key, module_key in API_TO_MODULE_MAP.items():
        if api_key in norm:
            norm[module_key] = norm.pop(api_key)
    if "state" in norm and norm["state"]:
        norm["enabled"] = norm["state"] == "ENABLED"
        norm.pop("state", None)
    for key in ID_LIST_ATTRS:
        if key in norm:
            norm[key] = _extract_ids(norm[key])
    for key in ("casb_email_label", "casb_tombstone_template"):
        if key in norm:
            norm[key] = _normalize_single_ref(norm[key])
    return norm


def _build_rule_params(module):
    params = {"type": module.params.get("type")}
    for attr in CASB_MALWARE_RULE_ATTRIBUTES:
        val = module.params.get(attr)
        if val is not None:
            params[attr] = val
    # Default enabled=True when state=present and not explicitly set (API may require state)
    if module.params.get("state") == "present" and "enabled" not in params:
        params["enabled"] = True
    return params


def _ids_as_int_list(val):
    """Extract IDs from list of refs and return as list of int."""
    if val is None:
        return None
    if not isinstance(val, list):
        return val
    out = []
    for item in val:
        if isinstance(item, dict) and "id" in item:
            out.append(int(item["id"]))
        elif isinstance(item, (int, float)):
            out.append(int(item))
    return out if out else None


def _existing_to_params(existing):
    """Convert existing rule dict to SDK param format for merge."""
    out = {"type": existing.get("type")}
    for attr in CASB_MALWARE_RULE_ATTRIBUTES:
        if attr == "enabled":
            if "state" in existing:
                out[attr] = existing["state"] == "ENABLED"
            continue
        if attr == "bucket_ids" and "buckets" in existing:
            out[attr] = _ids_as_int_list(existing["buckets"])
            continue
        if attr == "cloud_app_tenant_ids" and "cloud_app_tenants" in existing:
            out[attr] = _ids_as_int_list(existing["cloud_app_tenants"])
            continue
        if attr == "labels" and "labels" in existing:
            out[attr] = _ids_as_int_list(existing["labels"])
            continue
        if attr in existing:
            out[attr] = existing[attr]
    return out


def core(module):
    state = module.params.get("state")
    client = ZIAClientHelper(module)

    rule_id = module.params.get("id")
    rule_name = module.params.get("name")
    rule_type = module.params.get("type")

    rule_params = _build_rule_params(module)

    existing_rule = None

    if rule_id is not None:
        result, _unused, error = client.casb_malware_rules.get_rule(rule_id, rule_type)
        if error:
            module.fail_json(msg=f"Error fetching CASB Malware rule with id {rule_id}: {to_native(error)}")
        existing_rule = result.as_dict()
    else:
        result, _unused, error = client.casb_malware_rules.list_rules(query_params={"rule_type": rule_type})
        if error:
            module.fail_json(msg=f"Error listing CASB Malware rules: {to_native(error)}")
        rules_list = [r.as_dict() for r in result] if result else []
        if rule_name:
            for r in rules_list:
                if r.get("name") == rule_name:
                    existing_rule = r
                    break

    normalized_desired = normalize_rule(rule_params)
    normalized_existing = normalize_rule(existing_rule) if existing_rule else {}

    differences_detected = False
    for key, value in normalized_desired.items():
        existing_val = normalized_existing.get(key)
        if key in ID_LIST_ATTRS:
            if _extract_ids(value) != _extract_ids(existing_val):
                differences_detected = True
                break
        elif key in ("casb_email_label", "casb_tombstone_template"):
            if _normalize_single_ref(value) != _normalize_single_ref(existing_val):
                differences_detected = True
                break
        elif existing_val != value:
            differences_detected = True
            break

    if module.check_mode:
        if state == "present" and (existing_rule is None or differences_detected):
            module.exit_json(changed=True)
        elif state == "absent" and existing_rule:
            module.exit_json(changed=True)
        else:
            module.exit_json(changed=False)

    if state == "present":
        if existing_rule:
            if differences_detected:
                id_to_update = existing_rule.get("id")
                if not id_to_update:
                    module.fail_json(msg="Cannot update: ID is missing from the existing rule.")
                merged = _existing_to_params(existing_rule)
                for k, v in rule_params.items():
                    merged[k] = v

                updated, _unused, error = client.casb_malware_rules.update_rule(
                    id_to_update,
                    **merged,
                )
                if error:
                    module.fail_json(msg=f"Error updating CASB Malware rule: {to_native(error)}")
                module.exit_json(changed=True, data=updated.as_dict())
            else:
                module.exit_json(changed=False, data=existing_rule)
        else:
            new_rule, _unused, error = client.casb_malware_rules.add_rule(**rule_params)
            if error:
                module.fail_json(msg=f"Error adding CASB Malware rule: {to_native(error)}")
            module.exit_json(changed=True, data=new_rule.as_dict())

    elif state == "absent":
        if existing_rule:
            id_to_delete = existing_rule.get("id")
            if not id_to_delete:
                module.fail_json(msg="Cannot delete: ID is missing from the existing rule.")

            _unused, _unused, error = client.casb_malware_rules.delete_rule(
                rule_type,
                id_to_delete,
            )
            if error:
                module.fail_json(msg=f"Error deleting CASB Malware rule: {to_native(error)}")
            module.exit_json(changed=True, data=existing_rule)
        else:
            module.exit_json(changed=False, data={})

    else:
        module.exit_json(changed=False, data={})


def main():
    argument_spec = ZIAClientHelper.zia_argument_spec()
    argument_spec.update(
        dict(
            id=dict(type="int", required=False),
            name=dict(type="str", required=True),
            type=dict(type="str", required=True, choices=RULE_TYPE_CHOICES),
            description=dict(type="str", required=False),
            order=dict(type="int", required=True),
            rank=dict(type="int", required=False),
            enabled=dict(type="bool", required=False),
            action=dict(
                type="str",
                required=False,
                choices=[
                    "OFLCASB_AVP_QUARANTINE",
                    "OFLCASB_AVP_REMOVE",
                    "OFLCASB_AVP_REPORT_MALWARE",
                    "OFLCASB_AVP_APPLY_EMAIL_TAG",
                    "OFLCASB_AVP_BLOCK",
                    "OFLCASB_AVP_ALLOW",
                ],
            ),
            quarantine_location=dict(type="str", required=False),
            scan_inbound_email_link=dict(
                type="str",
                required=False,
                choices=["SCAN_EMAIL_LINK_ENABLE", "SCAN_EMAIL_LINK_DISABLE"],
            ),
            cloud_app_tenant_ids=dict(type="list", elements="int", required=False),
            labels=dict(type="list", elements="int", required=False),
            bucket_ids=dict(type="list", elements="int", required=False),
            casb_email_label=dict(type="dict", required=False),
            casb_tombstone_template=dict(type="dict", required=False),
            state=dict(type="str", choices=["present", "absent"], default="present"),
        )
    )
    module = AnsibleModule(argument_spec=argument_spec, supports_check_mode=True)
    try:
        core(module)
    except Exception as e:
        module.fail_json(msg=to_native(e), exception=format_exc())


if __name__ == "__main__":
    main()
